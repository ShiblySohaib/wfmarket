{% extends 'base.html' %}

{% block title %}Market - Warframe Market Manager{% endblock %}

{% block page_title %}Market{% endblock %}

{% block content %}
<div class="search-section">
    <div class="search-container">
        <input type="text" id="searchInput" placeholder="Search items, buyers, categories..." class="search-input">
        <i class="fas fa-search search-icon"></i>
    </div>
</div>

<div class="market-section">
    <div class="section-header">
        <div class="stats-container">
            <div class="market-info-card">
                <i class="fas fa-chart-line market-icon"></i>
                <div class="market-stats">
                    <span class="stats-label">Active Orders</span>
                    <span class="stats-count" id="activeOrdersCount">-</span>
                </div>
            </div>
            <div class="failed-info-card" id="failedCard" style="display: none;" onclick="showFailedItemsModal()" title="Click to see failed items">
                <i class="fas fa-exclamation-triangle failed-icon"></i>
                <div class="failed-stats">
                    <span class="stats-label">Failed Items</span>
                    <span class="stats-count" id="failedItemsCount">0</span>
                </div>
            </div>
        </div>
        <div class="progress-card" id="progressCard">
            <div class="progress-container">
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
                <div class="progress-text" id="progressText">0%</div>
            </div>
        </div>
        <div class="refresh-card" id="refreshCard" style="display: none;">
            <div class="refresh-container">
                <div class="last-updated" id="lastUpdated">Last updated: Just now</div>
                <button class="btn btn-refresh" onclick="refreshMarketData()" title="Refresh market data">
                    <i class="fas fa-sync-alt" id="refreshIcon"></i>
                    Refresh
                </button>
            </div>
        </div>
    </div>
    
    {% if not has_items %}
        <div class="empty-state">
            <p>No items in inventory to check market data for.</p>
        </div>
    {% else %}
        <div class="loading-state" id="loadingState">
            <div class="loading-spinner">
                <i class="fas fa-spinner fa-spin"></i>
            </div>
            <p>Fetching market data for {{ total_items }} items...</p>
        </div>
        
        <div class="table-container" id="tableContainer" style="display: none;">
            <table class="market-table" id="marketTable">
                <thead>
                    <tr>
                        <th>Item</th>
                        <th>Category</th>
                        <th>Source</th>
                        <th>Qty</th>
                        <th>Buyer</th>
                        <th>Platinum</th>
                        <th>Order Qty</th>
                        <th>Rank</th>
                        <th>Action</th>
                    </tr>
                </thead>
                <tbody id="marketTableBody">
                    <!-- Market data will be populated here -->
                </tbody>
            </table>
        </div>
    {% endif %}
</div>

<!-- Failed Items Modal -->
<div class="modal-overlay" id="failedItemsModal" style="display: none;">
    <div class="modal-content">
        <div class="modal-header">
            <h3 id="failedModalTitle"><i class="fas fa-exclamation-triangle"></i> Failed Items</h3>
            <button class="modal-close" onclick="hideFailedItemsModal()">
                <i class="fas fa-times"></i>
            </button>
        </div>
        <div class="modal-body">
            <div class="failed-table-container">
                <table class="failed-table">
                    <thead>
                        <tr>
                            <th>Item</th>
                            <th>Error Code</th>
                            <th>Fetched URL</th>
                        </tr>
                    </thead>
                    <tbody id="failedTableBody">
                        <!-- Failed items will be populated here -->
                    </tbody>
                </table>
            </div>
            <div class="failed-table-footer">
                <!-- Footer text removed as requested -->
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_css %}
<style>
:root {
    --accent-blue-rgb: 0, 212, 255; /* RGB values for accent-blue */
}

.search-section {
    display: flex;
    justify-content: center;
    margin-bottom: 30px;
}

.search-container {
    position: relative;
    width: 400px;
}

.search-input {
    width: 100%;
    padding: 15px 50px 15px 20px;
    background-color: var(--bg-secondary);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    color: var(--text-primary);
    font-size: 1.1rem;
    transition: all 0.3s ease;
}

.search-input:focus {
    outline: none;
    border-color: var(--accent-blue);
    box-shadow: 0 0 0 3px rgba(0, 212, 255, 0.2);
}

.search-input::placeholder {
    color: var(--text-muted);
}

.search-icon {
    position: absolute;
    right: 20px;
    top: 50%;
    transform: translateY(-50%);
    color: var(--text-muted);
    pointer-events: none;
    font-size: 1.1rem;
}

.market-section {
    margin: 0;
}

/* Enhanced table transition styles */
.market-table {
    border-collapse: separate;
    border-spacing: 0;
}

.market-row {
    transition: all 0.3s ease;
}

.market-row.new-row {
    animation: newRowHighlight 1s ease-out;
}

@keyframes newRowHighlight {
    0% {
        background-color: rgba(var(--accent-blue-rgb), 0.2);
        transform: scale(1.005);
    }
    50% {
        background-color: rgba(var(--accent-blue-rgb), 0.1);
    }
    100% {
        background-color: transparent;
        transform: scale(1);
    }
}

/* Smooth hover transitions */
.market-row:hover {
    background-color: var(--bg-tertiary);
    transform: translateY(-1px);
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
}

.section-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 20px;
    margin-bottom: 25px;
    padding-bottom: 15px;
    border-bottom: 2px solid var(--accent-blue);
}

.stats-container {
    display: flex;
    align-items: center;
    gap: 20px;
}

.market-info-card, .failed-info-card {
    display: flex;
    align-items: center;
    background-color: var(--bg-secondary);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    padding: 15px 20px;
    gap: 15px;
}

.market-icon {
    font-size: 1.3rem;
    color: var(--accent-blue);
}

.failed-icon {
    font-size: 1.3rem;
    color: var(--error);
}

.market-stats, .failed-stats {
    display: flex;
    align-items: center;
    gap: 8px;
}

.stats-label {
    color: var(--text-secondary);
    font-size: 0.85rem;
    text-transform: uppercase;
    letter-spacing: 1px;
    font-weight: 500;
}

.stats-count {
    color: var(--accent-blue);
    font-size: 1.4rem;
    font-weight: bold;
    line-height: 1;
}

.failed-info-card {
    color: var(--error);
    cursor: pointer;
    transition: all 0.2s ease;
}

.failed-info-card:hover {
    background-color: rgba(220, 53, 69, 0.1);
    border-color: var(--error);
    transform: translateY(-1px);
}

.failed-info-card .stats-count {
    color: var(--error);
}

/* Modal Styles */
.modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.7);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1000;
    backdrop-filter: blur(3px);
}

.modal-content {
    background-color: var(--bg-secondary);
    border: 1px solid var(--border-color);
    border-radius: 12px;
    width: 90%;
    max-width: 800px;
    max-height: 80vh;
    display: flex;
    flex-direction: column;
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
}

.modal-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 20px 25px;
    border-bottom: 1px solid var(--border-color);
    background-color: var(--bg-tertiary);
    border-radius: 12px 12px 0 0;
}

.modal-header h3 {
    color: var(--error);
    margin: 0;
    font-size: 1.3rem;
    display: flex;
    align-items: center;
    gap: 10px;
}

.modal-close {
    background: none;
    border: none;
    color: var(--text-secondary);
    font-size: 1.2rem;
    cursor: pointer;
    padding: 5px;
    border-radius: 4px;
    transition: all 0.2s ease;
}

.modal-close:hover {
    color: var(--error);
    background-color: rgba(220, 53, 69, 0.1);
}

.modal-body {
    padding: 0;
    overflow: hidden;
    flex: 1;
    display: flex;
    flex-direction: column;
}

.failed-table-container {
    overflow-y: auto;
    flex: 1;
    max-height: 50vh;
}

.failed-table {
    width: 100%;
    border-collapse: collapse;
}

.failed-table th {
    background-color: var(--bg-tertiary);
    color: var(--text-primary);
    padding: 15px 20px;
    text-align: left;
    font-weight: 600;
    text-transform: uppercase;
    font-size: 0.8rem;
    letter-spacing: 1px;
    border-bottom: 2px solid var(--border-color);
    position: sticky;
    top: 0;
    z-index: 10;
}

.failed-table td {
    padding: 12px 20px;
    border-bottom: 1px solid var(--border-color);
    color: var(--text-secondary);
    font-size: 0.9rem;
    vertical-align: top;
}

.failed-table tr:hover {
    background-color: var(--hover-color);
}

.failed-item-name {
    color: var(--accent-blue) !important;
    font-weight: 500;
    word-break: break-word;
}

.failed-error-code {
    color: var(--error) !important;
    font-weight: 600;
    font-family: monospace;
}

.failed-url {
    color: var(--text-muted) !important;
    font-family: monospace;
    font-size: 0.8rem;
    word-break: break-all;
    max-width: 300px;
}

.failed-table-footer {
    padding: 15px 25px;
    border-top: 1px solid var(--border-color);
    background-color: var(--bg-tertiary);
    border-radius: 0 0 12px 12px;
}

.failed-table-footer p {
    color: var(--text-muted);
    font-size: 0.9rem;
    margin: 0;
    text-align: center;
}

.progress-card {
    display: flex;
    align-items: center;
    background-color: var(--bg-secondary);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    padding: 15px 20px;
    height: 53px; /* Match stats card height */
}

.progress-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 8px;
    min-width: 150px;
}

.progress-bar {
    width: 100%;
    height: 8px;
    background-color: var(--bg-tertiary);
    border-radius: 4px;
    overflow: hidden;
    border: 1px solid var(--border-color);
}

.progress-fill {
    height: 100%;
    background: linear-gradient(90deg, var(--accent-blue), #00b8e6);
    width: 0%;
    transition: width 0.3s ease;
    border-radius: 3px;
}

.progress-text {
    color: var(--text-primary);
    font-size: 0.9rem;
    font-weight: 600;
    min-width: 40px;
    text-align: center;
}

.refresh-card {
    display: flex;
    align-items: center;
    background-color: var(--bg-secondary);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    padding: 15px 20px;
    height: 53px; /* Match stats card height */
    gap: 15px;
}

.refresh-container {
    display: flex;
    align-items: center;
    gap: 15px;
}

.last-updated {
    color: var(--text-secondary);
    font-size: 0.85rem;
    white-space: nowrap;
}

.btn-refresh {
    background-color: var(--accent-blue);
    color: var(--bg-primary);
    padding: 8px 12px;
    font-size: 0.9rem;
    display: flex;
    align-items: center;
    gap: 6px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-weight: 500;
    transition: all 0.2s ease;
    white-space: nowrap;
}

.btn-refresh:hover {
    background-color: #0099cc;
}

.btn-refresh:active {
    background-color: #007399;
    transform: scale(0.98);
}

.btn-refresh:disabled {
    background-color: var(--bg-tertiary);
    color: var(--text-muted);
    cursor: not-allowed;
}

.btn-refresh i {
    color: inherit;
    font-size: 0.8rem;
}

.btn-refresh.refreshing i {
    animation: spin 1s linear infinite;
}

@keyframes spin {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
}

.loading-state {
    text-align: center;
    padding: 60px 20px;
    color: var(--text-secondary);
}

.loading-spinner {
    font-size: 2rem;
    color: var(--accent-blue);
    margin-bottom: 20px;
}

.loading-state p {
    margin: 10px 0;
    font-size: 1.1rem;
}

.table-container {
    background-color: var(--bg-secondary);
    border-radius: 8px;
    overflow: hidden;
    border: 1px solid var(--border-color);
}

.market-table {
    width: 100%;
    border-collapse: collapse;
}

.market-table th {
    background-color: var(--bg-tertiary);
    color: var(--text-primary);
    padding: 15px 12px;
    text-align: center;
    font-weight: 600;
    text-transform: uppercase;
    font-size: 0.8rem;
    letter-spacing: 1px;
    border-bottom: 2px solid var(--border-color);
}

.market-table th:first-child {
    text-align: left;
}

.market-table td {
    padding: 12px;
    border-bottom: 1px solid var(--border-color);
    color: var(--text-secondary);
    text-align: center;
    font-size: 0.9rem;
}

.market-table td:first-child {
    text-align: left;
}

.market-row {
    transition: background-color 0.2s ease;
}

.market-row:hover {
    background-color: var(--hover-color);
}

.market-row:last-child td {
    border-bottom: none;
}

.market-item {
    color: var(--accent-blue) !important;
    font-weight: 500;
    max-width: 200px;
    word-wrap: break-word;
}

.market-category {
    color: var(--text-primary) !important;
}

.market-source {
    color: var(--text-primary) !important;
}

.market-inventory-qty {
    color: var(--accent-gold) !important;
    font-weight: 600;
}

.market-buyer {
    color: var(--text-primary) !important;
    font-weight: 500;
}

.reputation {
    color: var(--text-muted) !important;
    font-size: 0.8rem;
    font-weight: normal;
}

.market-platinum {
    color: #e6e6e6 !important;
    font-weight: bold;
    font-size: 1rem;
}

.market-order-qty {
    color: var(--accent-gold) !important;
    font-weight: 600;
}

.market-rank {
    color: var(--text-secondary) !important;
}

.market-actions {
    text-align: center;
    white-space: nowrap;
}

.btn-whisper {
    background-color: #4caf50;
    color: white;
    padding: 6px 12px;
    font-size: 0.85rem;
    display: inline-flex;
    align-items: center;
    gap: 6px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-weight: 500;
    transition: all 0.2s ease;
}

.btn-whisper:hover {
    background-color: #45a049;
}

.btn-whisper:active {
    background-color: #3d8b40;
    transform: scale(0.98);
}

.btn-whisper i {
    color: white;
    font-size: 0.8rem;
}

.failed-notice {
    color: var(--error) !important;
}

.empty-state {
    text-align: center;
    padding: 60px 20px;
    color: var(--text-secondary);
}

.empty-state p {
    margin: 10px 0;
    font-size: 1.1rem;
}

@media (max-width: 1200px) {
    .market-table {
        font-size: 0.85rem;
    }
    
    .market-table th,
    .market-table td {
        padding: 10px 8px;
    }
}

@media (max-width: 768px) {
    .table-container {
        overflow-x: auto;
    }
    
    .market-table {
        min-width: 900px;
    }
    
    .section-header {
        flex-direction: column;
        align-items: stretch;
        gap: 15px;
    }
    
    .search-container {
        width: 100%;
        max-width: 400px;
    }
}

/* Whisper copied notification */
.whisper-copied {
    position: fixed;
    top: 20px;
    right: 20px;
    background-color: var(--accent-blue);
    color: var(--bg-primary);
    padding: 12px 20px;
    border-radius: 8px;
    font-weight: 500;
    z-index: 1000;
    animation: slideIn 0.3s ease, slideOut 0.3s ease 2.7s;
}

@keyframes slideIn {
    from {
        transform: translateX(100%);
        opacity: 0;
    }
    to {
        transform: translateX(0);
        opacity: 1;
    }
}

@keyframes slideOut {
    from {
        transform: translateX(0);
        opacity: 1;
    }
    to {
        transform: translateX(100%);
        opacity: 0;
    }
}
</style>
{% endblock %}

{% block extra_js %}
<script>
// Market data fetching and progress tracking
let lastFetchTime = null;
let currentMarketData = [];
let updateTimeInterval = null;
let fetchSessionId = null;
let progressPollingInterval = null;
let autoRefreshInterval = null; // For 2-minute auto refresh
let failedItemsList = []; // Store failed items for modal

document.addEventListener('DOMContentLoaded', function() {
    const hasItems = {{ has_items|yesno:"true,false" }};
    
    if (hasItems) {
        fetchMarketData();
    }
    
    // Initialize search functionality
    initializeSearch();
});

function initializeSearch() {
    const searchInput = document.getElementById('searchInput');
    if (searchInput) {
        searchInput.addEventListener('input', function() {
            const searchTerm = this.value.toLowerCase().trim();
            filterTable(searchTerm);
        });
    }
}

function filterTable(searchTerm) {
    const table = document.getElementById('marketTable');
    if (!table) return;
    
    const rows = table.querySelectorAll('tbody tr');
    let visibleCount = 0;
    
    rows.forEach(row => {
        if (!searchTerm) {
            row.style.display = '';
            visibleCount++;
            return;
        }
        
        const item = row.querySelector('.market-item')?.textContent.toLowerCase() || '';
        const category = row.querySelector('.market-category')?.textContent.toLowerCase() || '';
        const source = row.querySelector('.market-source')?.textContent.toLowerCase() || '';
        const buyer = row.querySelector('.market-buyer')?.textContent.toLowerCase() || '';
        
        const matches = item.includes(searchTerm) || 
                       category.includes(searchTerm) || 
                       source.includes(searchTerm) || 
                       buyer.includes(searchTerm);
        
        if (matches) {
            row.style.display = '';
            visibleCount++;
        } else {
            row.style.display = 'none';
        }
    });
    
    // Update active orders count with filtered results
    const activeOrdersCount = document.getElementById('activeOrdersCount');
    if (activeOrdersCount && searchTerm) {
        activeOrdersCount.textContent = visibleCount;
    } else if (activeOrdersCount) {
        activeOrdersCount.textContent = currentMarketData.length;
    }
}

// Clean up intervals when page is unloaded
window.addEventListener('beforeunload', function() {
    if (progressPollingInterval) {
        clearInterval(progressPollingInterval);
    }
    if (updateTimeInterval) {
        clearInterval(updateTimeInterval);
    }
    if (autoRefreshInterval) {
        clearInterval(autoRefreshInterval);
    }
});

function fetchMarketData() {
    const progressCard = document.getElementById('progressCard');
    const refreshCard = document.getElementById('refreshCard');
    const refreshBtn = document.querySelector('.btn-refresh');
    const refreshIcon = document.getElementById('refreshIcon');
    
    // Show progress card, hide refresh card
    progressCard.style.display = 'flex';
    refreshCard.style.display = 'none';
    
    // Disable refresh button if it exists
    if (refreshBtn) {
        refreshBtn.disabled = true;
        refreshBtn.classList.add('refreshing');
    }
    
    const progressFill = document.getElementById('progressFill');
    const progressText = document.getElementById('progressText');
    const activeOrdersCount = document.getElementById('activeOrdersCount');
    const failedItemsCount = document.getElementById('failedItemsCount');
    const failedCard = document.getElementById('failedCard');
    const loadingState = document.getElementById('loadingState');
    const tableContainer = document.getElementById('tableContainer');
    
    function updateProgress(value) {
        progressFill.style.width = value + '%';
        progressText.textContent = Math.round(value) + '%';
    }
    
    // Start the fetch process
    fetch('/market/fetch-data/?action=start', {
        method: 'GET',
        headers: {
            'X-Requested-With': 'XMLHttpRequest',
        }
    })
    .then(response => response.json())
    .then(data => {
        if (data.status === 'started') {
            fetchSessionId = data.session_id;
            // Start polling for progress
            pollProgress();
        } else {
            throw new Error('Failed to start fetch process');
        }
    })
    .catch(error => {
        console.error('Error starting market data fetch:', error);
        handleFetchError();
    });
    
    function pollProgress() {
        if (!fetchSessionId) return;
        
        progressPollingInterval = setInterval(() => {
            fetch(`/market/fetch-data/?action=progress&session_id=${fetchSessionId}`, {
                method: 'GET',
                headers: {
                    'X-Requested-With': 'XMLHttpRequest',
                }
            })
            .then(response => response.json())
            .then(data => {
                // Update progress bar
                updateProgress(data.progress);
                
                // Update stats
                activeOrdersCount.textContent = data.total_orders;
                failedItemsCount.textContent = data.total_failed;
                
                // Only show failed card when fetching is complete
                if (data.status === 'complete' && data.total_failed > 0) {
                    failedCard.style.display = 'flex';
                } else {
                    failedCard.style.display = 'none';
                }
                
                // Update table with current data (every 10 items or when complete)
                if (data.market_data.length > 0) {
                    // Check if data has changed
                    const dataChanged = hasDataChanged(data.market_data);
                    
                    if (dataChanged || currentMarketData.length === 0) {
                        // Hide loading state on first data
                        if (loadingState && loadingState.style.display !== 'none') {
                            loadingState.style.display = 'none';
                        }
                        
                        // Update table
                        populateTable(data.market_data);
                        tableContainer.style.display = 'block';
                        
                        // Store current data
                        currentMarketData = data.market_data;
                    }
                }
                
                // Check if complete
                if (data.status === 'complete') {
                    clearInterval(progressPollingInterval);
                    progressPollingInterval = null;
                    
                    updateProgress(100);
                    lastFetchTime = new Date();
                    
                    // Store failed items for modal (only when complete)
                    if (data.failed_items && data.failed_items.length > 0) {
                        failedItemsList = data.failed_items;
                    }
                    
                    // Show refresh card and hide progress card
                    setTimeout(() => {
                        progressCard.style.display = 'none';
                        refreshCard.style.display = 'flex';
                        
                        // Enable refresh button
                        if (refreshBtn) {
                            refreshBtn.disabled = false;
                            refreshBtn.classList.remove('refreshing');
                        }
                        
                        // Start time update interval
                        updateLastUpdatedTime();
                        startTimeUpdateInterval();
                        
                        // Start auto-refresh for future updates
                        startAutoRefresh();
                    }, 1000);
                    
                    fetchSessionId = null;
                }
            })
            .catch(error => {
                console.error('Error polling progress:', error);
                clearInterval(progressPollingInterval);
                progressPollingInterval = null;
                handleFetchError();
            });
        }, 1000); // Poll every second
    }
    
    function handleFetchError() {
        if (loadingState) {
            loadingState.innerHTML = `
                <div class="loading-spinner">
                    <i class="fas fa-exclamation-triangle" style="color: var(--error);"></i>
                </div>
                <p style="color: var(--error);">Failed to load market data. Please try refreshing the page.</p>
            `;
        }
        
        // Show refresh card
        progressCard.style.display = 'none';
        refreshCard.style.display = 'flex';
        
        if (refreshBtn) {
            refreshBtn.disabled = false;
            refreshBtn.classList.remove('refreshing');
        }
    }
}

function refreshMarketData() {
    // Cancel any ongoing polling and auto-refresh
    if (progressPollingInterval) {
        clearInterval(progressPollingInterval);
        progressPollingInterval = null;
    }
    
    if (autoRefreshInterval) {
        clearInterval(autoRefreshInterval);
        autoRefreshInterval = null;
    }
    
    // Reset session and failed items
    fetchSessionId = null;
    failedItemsList = [];
    
    // Start fresh fetch
    fetchMarketData();
}

function hasDataChanged(newData) {
    if (currentMarketData.length !== newData.length) {
        return true;
    }
    
    // Simple comparison - in production you might want more sophisticated comparison
    const currentStr = JSON.stringify(currentMarketData.map(item => ({
        item: item.item,
        buyer: item.buyer,
        platinum: item.platinum,
        order_quantity: item.order_quantity
    })));
    
    const newStr = JSON.stringify(newData.map(item => ({
        item: item.item,
        buyer: item.buyer,
        platinum: item.platinum,
        order_quantity: item.order_quantity
    })));
    
    return currentStr !== newStr;
}

function updateLastUpdatedTime() {
    if (!lastFetchTime) return;
    
    const now = new Date();
    const diff = Math.floor((now - lastFetchTime) / 1000); // seconds
    const lastUpdatedElement = document.getElementById('lastUpdated');
    
    if (!lastUpdatedElement) return;
    
    let timeText;
    let nextUpdateIn; // seconds until next update needed
    
    if (diff < 60) {
        timeText = 'Just now';
        nextUpdateIn = 60 - diff;
    } else if (diff < 3600) {
        const minutes = Math.floor(diff / 60);
        timeText = `${minutes}m ago`;
        nextUpdateIn = 60 - (diff % 60);
    } else {
        const hours = Math.floor(diff / 3600);
        timeText = `${hours}h ago`;
        nextUpdateIn = 3600 - (diff % 3600);
    }
    
    lastUpdatedElement.textContent = `Last updated: ${timeText}`;
    return nextUpdateIn;
}

function startTimeUpdateInterval() {
    if (updateTimeInterval) {
        clearInterval(updateTimeInterval);
    }
    
    function scheduleNextUpdate() {
        const nextUpdateIn = updateLastUpdatedTime();
        if (nextUpdateIn) {
            updateTimeInterval = setTimeout(() => {
                updateLastUpdatedTime();
                scheduleNextUpdate();
            }, nextUpdateIn * 1000);
        }
    }
    
    scheduleNextUpdate();
}

function startAutoRefresh() {
    // Clear any existing auto-refresh interval
    if (autoRefreshInterval) {
        clearInterval(autoRefreshInterval);
    }
    
    // Start auto-refresh every 2 minutes (120000 ms)
    autoRefreshInterval = setInterval(() => {
        console.log('Auto-refreshing market data...');
        refreshMarketDataInBackground();
    }, 120000);
}

function refreshMarketDataInBackground() {
    // Don't start a new refresh if one is already in progress
    if (progressPollingInterval || fetchSessionId) {
        console.log('Refresh already in progress, skipping auto-refresh');
        return;
    }
    
    // Store the current data to compare later
    const previousData = [...currentMarketData];
    const previousFailedCount = failedItemsList.length;
    
    // Start the fetch process silently (no UI changes)
    fetch('/market/fetch-data/?action=start', {
        method: 'GET',
        headers: {
            'X-Requested-With': 'XMLHttpRequest',
        }
    })
    .then(response => response.json())
    .then(data => {
        if (data.status === 'started') {
            const sessionId = data.session_id;
            
            // Poll for progress silently
            const silentPoll = setInterval(() => {
                fetch(`/market/fetch-data/?action=progress&session_id=${sessionId}`, {
                    method: 'GET',
                    headers: {
                        'X-Requested-With': 'XMLHttpRequest',
                    }
                })
                .then(response => response.json())
                .then(progressData => {
                    if (progressData.status === 'complete') {
                        clearInterval(silentPoll);
                        
                        // Check if data has actually changed
                        const dataChanged = hasDataChanged(progressData.market_data);
                        const failedCountChanged = progressData.total_failed !== previousFailedCount;
                        
                        if (dataChanged || failedCountChanged) {
                            console.log('Data changed, updating UI...');
                            
                            // Update the UI with new data
                            const activeOrdersCount = document.getElementById('activeOrdersCount');
                            const failedItemsCount = document.getElementById('failedItemsCount');
                            const failedCard = document.getElementById('failedCard');
                            const tableContainer = document.getElementById('tableContainer');
                            
                            // Update stats
                            activeOrdersCount.textContent = progressData.total_orders;
                            failedItemsCount.textContent = progressData.total_failed;
                            
                            // Show/hide failed card based on completion and failed count
                            if (progressData.total_failed > 0) {
                                failedCard.style.display = 'flex';
                            } else {
                                failedCard.style.display = 'none';
                            }
                            
                            // Update table if there's market data
                            if (progressData.market_data.length > 0) {
                                populateTable(progressData.market_data);
                                tableContainer.style.display = 'block';
                                currentMarketData = progressData.market_data;
                            }
                            
                            // Update failed items for modal
                            if (progressData.failed_items && progressData.failed_items.length > 0) {
                                failedItemsList = progressData.failed_items;
                            }
                            
                            // Update last fetch time and display
                            lastFetchTime = new Date();
                            updateLastUpdatedTime();
                            
                        } else {
                            console.log('No data changes detected, skipping UI update');
                        }
                    }
                })
                .catch(error => {
                    console.error('Error in silent polling:', error);
                    clearInterval(silentPoll);
                });
            }, 1000);
        }
    })
    .catch(error => {
        console.error('Error starting background refresh:', error);
    });
}

function populateTable(marketData) {
    const tbody = document.getElementById('marketTableBody');
    
    // Get existing rows
    const existingRows = Array.from(tbody.querySelectorAll('tr'));
    
    // Create a more sophisticated comparison
    const createRowKey = (order) => `${order.item}-${order.buyer}-${order.platinum}-${order.order_quantity}`;
    
    // Map existing rows by their data
    const existingRowMap = new Map();
    existingRows.forEach((row, index) => {
        const item = row.querySelector('.market-item')?.textContent;
        const buyer = row.querySelector('.market-buyer')?.textContent?.split('(')[0]?.trim();
        const platinum = row.querySelector('.market-platinum')?.textContent;
        const quantity = row.querySelector('.market-order-qty')?.textContent;
        
        if (item && buyer && platinum && quantity) {
            const key = `${item}-${buyer}-${platinum}-${quantity}`;
            existingRowMap.set(key, { row, index });
        }
    });
    
    // Create new row elements
    const newRows = [];
    const newRowKeys = new Set();
    
    marketData.forEach((order, index) => {
        const rowKey = createRowKey(order);
        newRowKeys.add(rowKey);
        
        const row = document.createElement('tr');
        row.className = 'market-row';
        row.dataset.rowKey = rowKey;
        
        const rankText = order.rank > 0 ? `Rank ${order.rank}` : 'Unranked';
        
        row.innerHTML = `
            <td class="market-item">${order.item}</td>
            <td class="market-category">${order.category.charAt(0).toUpperCase() + order.category.slice(1)}</td>
            <td class="market-source">${order.source.charAt(0).toUpperCase() + order.source.slice(1)}</td>
            <td class="market-inventory-qty">${order.inventory_quantity}</td>
            <td class="market-buyer">
                ${order.buyer}
                <span class="reputation" title="Reputation: ${order.user_reputation}">
                    (${order.user_reputation})
                </span>
            </td>
            <td class="market-platinum">${order.platinum}</td>
            <td class="market-order-qty">${order.order_quantity}</td>
            <td class="market-rank">${rankText}</td>
            <td class="market-actions">
                <button class="btn btn-whisper" onclick="copyWhisper('${order.buyer}', '${order.item}', ${order.platinum}, ${order.order_quantity})" title="Copy whisper message">
                    <i class="fas fa-comment"></i>
                    Whisper
                </button>
            </td>
        `;
        
        // Check if this is a new row
        const isNewRow = !existingRowMap.has(rowKey);
        if (isNewRow) {
            row.classList.add('new-row');
            // Set initial animation state
            row.style.opacity = '0';
            row.style.transform = 'translateY(15px) scale(0.98)';
        }
        
        newRows.push({ row, isNew: isNewRow, index });
    });
    
    // Remove rows that are no longer in the data
    existingRows.forEach(row => {
        const rowKey = row.dataset.rowKey;
        if (rowKey && !newRowKeys.has(rowKey)) {
            row.style.transition = 'opacity 0.2s ease-out, transform 0.2s ease-out';
            row.style.opacity = '0';
            row.style.transform = 'translateX(-20px) scale(0.98)';
            setTimeout(() => {
                if (row.parentNode) {
                    row.parentNode.removeChild(row);
                }
            }, 200);
        }
    });
    
    // Clear and add all rows
    setTimeout(() => {
        tbody.innerHTML = '';
        
        newRows.forEach(({ row, isNew, index }) => {
            tbody.appendChild(row);
            
            if (isNew) {
                // Animate new rows in with staggered timing
                setTimeout(() => {
                    row.style.transition = 'opacity 0.3s ease-out, transform 0.3s ease-out';
                    row.style.opacity = '1';
                    row.style.transform = 'translateY(0) scale(1)';
                    
                    // Add special highlight for new rows
                    setTimeout(() => {
                        row.style.transition = 'background-color 0.2s ease-out';
                        row.style.backgroundColor = 'rgba(var(--accent-blue-rgb), 0.15)';
                        
                        setTimeout(() => {
                            row.style.backgroundColor = '';
                            row.classList.remove('new-row');
                        }, 500);
                    }, 100);
                }, index * 30); // Stagger by 30ms per row
            } else {
                // Existing rows appear immediately
                row.style.opacity = '1';
                row.style.transform = 'translateY(0) scale(1)';
            }
        });
    }, 100); // Small delay to allow exit animations
    
    // Reapply search filter after table update
    setTimeout(() => {
        const searchInput = document.getElementById('searchInput');
        if (searchInput && searchInput.value.trim()) {
            filterTable(searchInput.value.toLowerCase().trim());
        }
    }, 200);
}

function copyWhisper(buyer, itemName, platinum, quantity) {
    // Format the whisper message according to Warframe Market standards
    const whisperMessage = `/w ${buyer} Hi! I want to buy: ${itemName} for ${platinum} platinum. (warframe.market)`;
    
    // Copy to clipboard
    navigator.clipboard.writeText(whisperMessage).then(function() {
        // Show success notification
        showNotification('Whisper message copied to clipboard!');
    }, function(err) {
        // Fallback for older browsers
        const textArea = document.createElement('textarea');
        textArea.value = whisperMessage;
        document.body.appendChild(textArea);
        textArea.select();
        document.execCommand('copy');
        document.body.removeChild(textArea);
        showNotification('Whisper message copied to clipboard!');
    });
}

function showNotification(message) {
    // Remove existing notification if any
    const existing = document.querySelector('.whisper-copied');
    if (existing) {
        existing.remove();
    }
    
    // Create new notification
    const notification = document.createElement('div');
    notification.className = 'whisper-copied';
    notification.textContent = message;
    document.body.appendChild(notification);
    
    // Remove after animation
    setTimeout(() => {
        if (notification.parentNode) {
            notification.remove();
        }
    }, 3000);
}

function showFailedItemsModal() {
    // Populate the failed items table
    populateFailedItemsTable(failedItemsList);
    
    // Show the modal
    document.getElementById('failedItemsModal').style.display = 'flex';
}

function hideFailedItemsModal() {
    document.getElementById('failedItemsModal').style.display = 'none';
}

function populateFailedItemsTable(failedItems) {
    const tbody = document.getElementById('failedTableBody');
    const modalTitle = document.getElementById('failedModalTitle');
    
    tbody.innerHTML = '';
    
    if (failedItems.length === 0) {
        modalTitle.innerHTML = '<i class="fas fa-exclamation-triangle"></i> No Failed Items';
        return;
    }
    
    // Update modal title with count
    modalTitle.innerHTML = `<i class="fas fa-exclamation-triangle"></i> ${failedItems.length} Failed Item${failedItems.length === 1 ? '' : 's'}`;
    
    failedItems.forEach(failed => {
        const row = document.createElement('tr');
        
        row.innerHTML = `
            <td class="failed-item-name">${failed.item}</td>
            <td class="failed-error-code">${failed.error}</td>
            <td class="failed-url">${failed.url}</td>
        `;
        
        tbody.appendChild(row);
    });
}

// Close modal when clicking outside
document.addEventListener('click', function(event) {
    const modal = document.getElementById('failedItemsModal');
    if (event.target === modal) {
        hideFailedItemsModal();
    }
});

// Close modal with Escape key
document.addEventListener('keydown', function(event) {
    if (event.key === 'Escape') {
        hideFailedItemsModal();
    }
});

// Clean up intervals when page unloads
window.addEventListener('beforeunload', function() {
    if (updateTimeInterval) {
        clearInterval(updateTimeInterval);
    }
    if (progressPollingInterval) {
        clearInterval(progressPollingInterval);
    }
});
</script>
{% endblock %}
